Lets start!

The matrix sizes are:
p[0]: [70x99]
p[1]: [99x10]
p[2]: [10x54]
p[3]: [54x95]
p[4]: [95x42]
p[5]: [42x42]
p[6]: [42x17]
p[7]: [17x83]
p[8]: [83x81]
p[9]: [81x43]


Now the evaluation results: 

Results for minimum Flops:

The chain is the following: [ (0, 1)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(1, 9) ]

Sequential results:

The wall time that is needed for cost function F at 1000 iterations: 1.7058548


Parallel results

The wall time that is needed for cost function F with 1000 iterations: 0.5332111


Results for random costs:

The chain is the following: [ (0, 1)(3, 4)(2, 4)(1, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9) ]

Sequential results:

The wall time that is needed for cost function R at 1000 iterations: 6.7482281


Parallel results

The wall time that is needed for cost function R with 1000 iterations: 1.0371930


Results for minimal Memory usage:

The chain is the following: [ (0, 1)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(1, 9) ]

Sequential results:

The wall time that is needed for cost function M at 1000 iterations: 1.4509577


Parallel results

The wall time that is needed for cost function M with 1000 iterations: 0.4838821


Results for optimale cache usage:

The chain is the following: [ (1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(0, 8)(8, 9) ]

Sequential results:

The wall time that is needed for cost function C at 1000 iterations: 5.5758782


Parallel results

The wall time that is needed for cost function C with 1000 iterations: 1.6876301


Results for optimzed with multiple cores:

The chain is the following: [ (0, 1)(2, 3)(3, 4)(4, 5)(5, 6)(1, 6)(7, 8)(8, 9)(6, 9) ]

Sequential results:

The wall time that is needed for cost function P at 1000 iterations: 0.6113159


Parallel results

The wall time that is needed for cost function P with 1000 iterations: 0.3513914

Done! 


./main.x  82.33s user 3.22s system 417% cpu 20.483 total
