Lets start!

The matrix sizes are:
p[0]: [14x40]
p[1]: [40x89]
p[2]: [89x42]
p[3]: [42x97]
p[4]: [97x66]
p[5]: [66x19]
p[6]: [19x18]
p[7]: [18x10]
p[8]: [10x65]
p[9]: [65x36]


Now the evaluation results: 

Results for minimum Flops:

The chain is the following: [ (6, 7)(5, 7)(4, 7)(3, 7)(2, 7)(1, 7)(0, 7)(8, 9)(7, 9) ]

Sequential results:

The wall time that is needed for cost function F at 1000 iterations: 0.6084420


Parallel results

The wall time that is needed for cost function F with 1000 iterations: 0.3880759


Results for random costs:

The chain is the following: [ (4, 5)(5, 6)(3, 6)(7, 8)(6, 8)(2, 8)(1, 8)(8, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function R at 1000 iterations: 2.1118590


Parallel results

The wall time that is needed for cost function R with 1000 iterations: 0.8486977


Results for minimal Memory usage:

The chain is the following: [ (6, 7)(5, 7)(4, 7)(3, 7)(2, 7)(1, 7)(0, 7)(8, 9)(7, 9) ]

Sequential results:

The wall time that is needed for cost function M at 1000 iterations: 0.5426132


Parallel results

The wall time that is needed for cost function M with 1000 iterations: 0.3892048


Results for optimale cache usage:

The chain is the following: [ (7, 8)(6, 8)(5, 8)(4, 8)(3, 8)(2, 8)(8, 9)(1, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function C at 1000 iterations: 3.0880238


Parallel results

The wall time that is needed for cost function C with 1000 iterations: 1.1193682


Results for optimzed with multiple cores:

The chain is the following: [ (0, 1)(1, 2)(6, 7)(5, 7)(4, 7)(3, 7)(8, 9)(7, 9)(2, 9) ]

Sequential results:

The wall time that is needed for cost function P at 1000 iterations: 0.6301502


Parallel results

The wall time that is needed for cost function P with 1000 iterations: 0.3406790

Done! 


./main.x  42.57s user 2.39s system 438% cpu 10.249 total
