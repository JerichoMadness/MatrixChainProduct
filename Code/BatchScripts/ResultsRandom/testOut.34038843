Lets start!

The matrix sizes are:
p[0]: [82x54]
p[1]: [54x38]
p[2]: [38x10]
p[3]: [10x45]
p[4]: [45x39]
p[5]: [39x61]
p[6]: [61x95]
p[7]: [95x39]
p[8]: [39x22]
p[9]: [22x27]


Now the evaluation results: 

Results for minimum Flops:

The chain is the following: [ (1, 2)(0, 2)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(2, 9) ]

Sequential results:

The wall time that is needed for cost function F at 1000 iterations: 0.6528502


Parallel results

The wall time that is needed for cost function F with 1000 iterations: 0.3585126


Results for random costs:

The chain is the following: [ (5, 6)(4, 6)(3, 6)(2, 6)(7, 8)(6, 8)(8, 9)(1, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function R at 1000 iterations: 2.5761174


Parallel results

The wall time that is needed for cost function R with 1000 iterations: 1.0394201


Results for minimal Memory usage:

The chain is the following: [ (1, 2)(0, 2)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(2, 9) ]

Sequential results:

The wall time that is needed for cost function M at 1000 iterations: 0.5750610


Parallel results

The wall time that is needed for cost function M with 1000 iterations: 0.3420810


Results for optimale cache usage:

The chain is the following: [ (2, 3)(1, 3)(3, 4)(4, 5)(0, 5)(5, 6)(6, 7)(7, 8)(8, 9) ]

Sequential results:

The wall time that is needed for cost function C at 1000 iterations: 3.3894445


Parallel results

The wall time that is needed for cost function C with 1000 iterations: 1.0882792


Results for optimzed with multiple cores:

The chain is the following: [ (1, 2)(0, 2)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(2, 9) ]

Sequential results:

The wall time that is needed for cost function P at 1000 iterations: 0.4915555


Parallel results

The wall time that is needed for cost function P with 1000 iterations: 0.3382879

Done! 


./main.x  45.26s user 2.34s system 430% cpu 11.047 total
