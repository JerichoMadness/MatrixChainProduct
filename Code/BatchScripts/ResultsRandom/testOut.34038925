Lets start!

The matrix sizes are:
p[0]: [72x30]
p[1]: [30x94]
p[2]: [94x56]
p[3]: [56x65]
p[4]: [65x84]
p[5]: [84x63]
p[6]: [63x42]
p[7]: [42x52]
p[8]: [52x49]
p[9]: [49x67]


Now the evaluation results: 

Results for minimum Flops:

The chain is the following: [ (1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function F at 1000 iterations: 8.7163454


Parallel results

The wall time that is needed for cost function F with 1000 iterations: 1.0286813


Results for random costs:

The chain is the following: [ (1, 2)(2, 3)(0, 3)(7, 8)(6, 8)(5, 8)(8, 9)(4, 9)(3, 9) ]

Sequential results:

The wall time that is needed for cost function R at 1000 iterations: 3.4974847


Parallel results

The wall time that is needed for cost function R with 1000 iterations: 0.9814386


Results for minimal Memory usage:

The chain is the following: [ (1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function M at 1000 iterations: 8.1923077


Parallel results

The wall time that is needed for cost function M with 1000 iterations: 0.9269099


Results for optimale cache usage:

The chain is the following: [ (0, 1)(1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9) ]

Sequential results:

The wall time that is needed for cost function C at 1000 iterations: 7.8889604


Parallel results

The wall time that is needed for cost function C with 1000 iterations: 1.5190169


Results for optimzed with multiple cores:

The chain is the following: [ (1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(0, 6)(7, 8)(8, 9)(6, 9) ]

Sequential results:

The wall time that is needed for cost function P at 1000 iterations: 3.6544733


Parallel results

The wall time that is needed for cost function P with 1000 iterations: 0.9879540

Done! 


./main.x  149.66s user 4.05s system 407% cpu 37.729 total
