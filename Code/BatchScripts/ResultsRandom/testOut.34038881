Lets start!

The matrix sizes are:
p[0]: [57x14]
p[1]: [14x36]
p[2]: [36x31]
p[3]: [31x39]
p[4]: [39x57]
p[5]: [57x64]
p[6]: [64x46]
p[7]: [46x99]
p[8]: [99x87]
p[9]: [87x71]


Now the evaluation results: 

Results for minimum Flops:

The chain is the following: [ (1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function F at 1000 iterations: 1.8405499


Parallel results

The wall time that is needed for cost function F with 1000 iterations: 0.7222382


Results for random costs:

The chain is the following: [ (0, 1)(2, 3)(3, 4)(1, 4)(8, 9)(7, 9)(6, 9)(5, 9)(4, 9) ]

Sequential results:

The wall time that is needed for cost function R at 1000 iterations: 5.1758354


Parallel results

The wall time that is needed for cost function R with 1000 iterations: 0.8873175


Results for minimal Memory usage:

The chain is the following: [ (1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function M at 1000 iterations: 1.7705285


Parallel results

The wall time that is needed for cost function M with 1000 iterations: 0.6511268


Results for optimale cache usage:

The chain is the following: [ (0, 1)(1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9) ]

Sequential results:

The wall time that is needed for cost function C at 1000 iterations: 3.9792149


Parallel results

The wall time that is needed for cost function C with 1000 iterations: 1.0838014


Results for optimzed with multiple cores:

The chain is the following: [ (1, 2)(2, 3)(3, 4)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function P at 1000 iterations: 1.3489568


Parallel results

The wall time that is needed for cost function P with 1000 iterations: 0.6018506

Done! 


./main.x  73.06s user 3.01s system 415% cpu 18.306 total
