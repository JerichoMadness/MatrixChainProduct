Lets start!

The matrix sizes are:
p[0]: [36x78]
p[1]: [78x32]
p[2]: [32x19]
p[3]: [19x17]
p[4]: [17x86]
p[5]: [86x93]
p[6]: [93x21]
p[7]: [21x27]
p[8]: [27x41]
p[9]: [41x23]


Now the evaluation results: 

Results for minimum Flops:

The chain is the following: [ (2, 3)(1, 3)(0, 3)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(3, 9) ]

Sequential results:

The wall time that is needed for cost function F at 1000 iterations: 0.4889510


Parallel results

The wall time that is needed for cost function F with 1000 iterations: 0.3416812


Results for random costs:

The chain is the following: [ (3, 4)(2, 4)(4, 5)(5, 6)(6, 7)(1, 7)(8, 9)(7, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function R at 1000 iterations: 1.4682245


Parallel results

The wall time that is needed for cost function R with 1000 iterations: 0.6524036


Results for minimal Memory usage:

The chain is the following: [ (0, 1)(1, 2)(4, 5)(5, 6)(6, 7)(8, 9)(7, 9)(3, 9)(2, 9) ]

Sequential results:

The wall time that is needed for cost function M at 1000 iterations: 0.5924817


Parallel results

The wall time that is needed for cost function M with 1000 iterations: 0.3428104


Results for optimale cache usage:

The chain is the following: [ (3, 4)(2, 4)(1, 4)(4, 5)(5, 6)(6, 7)(7, 8)(0, 8)(8, 9) ]

Sequential results:

The wall time that is needed for cost function C at 1000 iterations: 3.3018404


Parallel results

The wall time that is needed for cost function C with 1000 iterations: 1.0661235


Results for optimzed with multiple cores:

The chain is the following: [ (2, 3)(1, 3)(0, 3)(4, 5)(5, 6)(6, 7)(7, 8)(8, 9)(3, 9) ]

Sequential results:

The wall time that is needed for cost function P at 1000 iterations: 0.3993277


Parallel results

The wall time that is needed for cost function P with 1000 iterations: 0.3027190

Done! 


./main.x  38.20s user 2.13s system 440% cpu 9.155 total
