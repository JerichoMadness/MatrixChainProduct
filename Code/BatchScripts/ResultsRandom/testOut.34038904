Lets start!

The matrix sizes are:
p[0]: [55x21]
p[1]: [21x87]
p[2]: [87x46]
p[3]: [46x30]
p[4]: [30x49]
p[5]: [49x13]
p[6]: [13x28]
p[7]: [28x75]
p[8]: [75x65]
p[9]: [65x32]


Now the evaluation results: 

Results for minimum Flops:

The chain is the following: [ (4, 5)(3, 5)(2, 5)(1, 5)(0, 5)(6, 7)(7, 8)(8, 9)(5, 9) ]

Sequential results:

The wall time that is needed for cost function F at 1000 iterations: 0.7234548


Parallel results

The wall time that is needed for cost function F with 1000 iterations: 0.3635096


Results for random costs:

The chain is the following: [ (2, 3)(3, 4)(1, 4)(0, 4)(6, 7)(7, 8)(8, 9)(5, 9)(4, 9) ]

Sequential results:

The wall time that is needed for cost function R at 1000 iterations: 1.6734606


Parallel results

The wall time that is needed for cost function R with 1000 iterations: 0.6138379


Results for minimal Memory usage:

The chain is the following: [ (1, 2)(4, 5)(3, 5)(2, 5)(6, 7)(7, 8)(8, 9)(5, 9)(0, 9) ]

Sequential results:

The wall time that is needed for cost function M at 1000 iterations: 0.4391640


Parallel results

The wall time that is needed for cost function M with 1000 iterations: 0.3229394


Results for optimale cache usage:

The chain is the following: [ (5, 6)(4, 6)(3, 6)(2, 6)(1, 6)(0, 6)(6, 7)(7, 8)(8, 9) ]

Sequential results:

The wall time that is needed for cost function C at 1000 iterations: 2.0336889


Parallel results

The wall time that is needed for cost function C with 1000 iterations: 0.7369346


Results for optimzed with multiple cores:

The chain is the following: [ (4, 5)(3, 5)(2, 5)(1, 5)(0, 5)(6, 7)(7, 8)(8, 9)(5, 9) ]

Sequential results:

The wall time that is needed for cost function P at 1000 iterations: 0.5936133


Parallel results

The wall time that is needed for cost function P with 1000 iterations: 0.3408233

Done! 


./main.x  33.70s user 2.07s system 446% cpu 8.020 total
